#!/usr/bin/env python3
"""
    --- AUTO-GENERATED DOCSTRING ---
    Table of content is automatically generated by Agent Docstrings v1.3.5
    
    Classes/Functions:
        - DevelopmentTestRunner (line 58):
            - run_quick_tests() -> Dict[str, Any] (line 67)
            - run_component_tests(component: str) -> Dict[str, Any] (line 111)
            - run_watch_mode() (line 144)
            - run_with_profiling() (line 197)
            - _test_imports() -> bool (line 230)
            - _test_basic_functionality() -> bool (line 243)
            - _test_configuration() -> bool (line 258)
            - _test_error_handling() -> bool (line 278)
            - _test_mathematical_processor() -> bool (line 300)
            - _test_content_classifier() -> bool (line 323)
            - _test_enhanced_chunker() -> bool (line 347)
            - _test_asset_processor() -> bool (line 363)
            - _test_glossary_extractor() -> bool (line 379)
            - _test_enhanced_scirag() -> bool (line 395)
        - main() (line 414)
    --- END AUTO-GENERATED DOCSTRING ---

Enhanced SciRAG Development Test Runner

This script provides specialized testing functionality for development,
including quick tests, specific component tests, and development-specific
validation.

Usage:
    python run_dev_tests.py                    # Run all development tests
    python run_dev_tests.py --quick            # Run quick smoke tests
    python run_dev_tests.py --unit             # Run unit tests only
    python run_dev_tests.py --integration      # Run integration tests only
    python run_dev_tests.py --performance      # Run performance tests only
    python run_dev_tests.py --component <name> # Test specific component
    python run_dev_tests.py --watch            # Watch mode for continuous testing
    python run_dev_tests.py --coverage         # Run with coverage
    python run_dev_tests.py --profile          # Run with profiling
"""
import sys
import os
import argparse
import time
import subprocess
import threading
import watchdog
from pathlib import Path
from typing import List, Dict, Any, Optional
import json

# Add the project root to Python path
project_root = Path(__file__).parent
sys.path.insert(0, str(project_root))


class DevelopmentTestRunner:
    """Development-focused test runner for Enhanced SciRAG."""

    def __init__(self):
        self.project_root = project_root
        self.test_results = {}
        self.start_time = time.time()
        self.watch_mode = False

    def run_quick_tests(self) -> Dict[str, Any]:
        """Run quick smoke tests for development."""
        print("üöÄ Quick Development Tests")
        print("=" * 40)

        tests = [
            ("Import Test", self._test_imports),
            ("Basic Functionality", self._test_basic_functionality),
            ("Configuration", self._test_configuration),
            ("Error Handling", self._test_error_handling),
        ]

        results = {}
        total_passed = 0
        total_failed = 0

        for test_name, test_func in tests:
            print(f"\nüß™ {test_name}...")
            try:
                result = test_func()
                if result:
                    print(f"  ‚úÖ {test_name}: PASSED")
                    total_passed += 1
                else:
                    print(f"  ‚ùå {test_name}: FAILED")
                    total_failed += 1
                results[test_name] = result
            except Exception as e:
                print(f"  üí• {test_name}: ERROR - {e}")
                total_failed += 1
                results[test_name] = False

        duration = time.time() - self.start_time
        print(f"\nüìä Quick Test Summary")
        print(f"Passed: {total_passed}, Failed: {total_failed}")
        print(f"Duration: {duration:.2f}s")

        return {
            'passed': total_passed,
            'failed': total_failed,
            'duration': duration,
            'results': results
        }

    def run_component_tests(self, component: str) -> Dict[str, Any]:
        """Run tests for a specific component."""
        print(f"üîß Testing Component: {component}")
        print("=" * 40)

        component_tests = {
            'mathematical': self._test_mathematical_processor,
            'classifier': self._test_content_classifier,
            'chunker': self._test_enhanced_chunker,
            'asset': self._test_asset_processor,
            'glossary': self._test_glossary_extractor,
            'enhanced': self._test_enhanced_scirag,
            'config': self._test_configuration,
        }

        if component not in component_tests:
            print(f"‚ùå Unknown component: {component}")
            print(f"Available components: {', '.join(component_tests.keys())}")
            return {
                'passed': False,
                'error': f'Unknown component: {component}'}

        try:
            result = component_tests[component]()
            if result:
                print(f"‚úÖ {component} component: PASSED")
            else:
                print(f"‚ùå {component} component: FAILED")
            return {'passed': result}
        except Exception as e:
            print(f"üí• {component} component: ERROR - {e}")
            return {'passed': False, 'error': str(e)}

    def run_watch_mode(self):
        """Run in watch mode for continuous testing."""
        print("üëÄ Watch Mode - Monitoring for changes...")
        print("Press Ctrl+C to stop")

        try:
            import watchdog
            from watchdog.observers import Observer
            from watchdog.events import FileSystemEventHandler

            class TestEventHandler(FileSystemEventHandler):
                def __init__(self, runner):
                    self.runner = runner
                    self.last_run = 0

                def on_modified(self, event):
                    if event.is_directory:
                        return

                    # Only run tests for Python files
                    if not event.src_path.endswith('.py'):
                        return

                    # Throttle test runs
                    current_time = time.time()
                    if current_time - self.last_run < 2:  # 2 second throttle
                        return

                    self.last_run = current_time
                    print(f"\nüîÑ File changed: {event.src_path}")
                    print("Running quick tests...")
                    self.runner.run_quick_tests()

            event_handler = TestEventHandler(self)
            observer = Observer()
            observer.schedule(
                event_handler, str(
                    self.project_root), recursive=True)
            observer.start()

            try:
                while True:
                    time.sleep(1)
            except KeyboardInterrupt:
                observer.stop()
                print("\nüëã Watch mode stopped")

            observer.join()

        except ImportError:
            print("‚ùå Watchdog not installed. Install with: pip install watchdog")
            return False

    def run_with_profiling(self):
        """Run tests with profiling."""
        print("üìä Running tests with profiling...")

        try:
            import cProfile
            import pstats

            profiler = cProfile.Profile()
            profiler.enable()

            # Run tests
            result = self.run_quick_tests()

            profiler.disable()

            # Save profile
            profile_file = self.project_root / "test_profile.prof"
            profiler.dump_stats(str(profile_file))

            # Print stats
            stats = pstats.Stats(profiler)
            stats.sort_stats('cumulative')
            stats.print_stats(20)  # Top 20 functions

            print(f"\nüìÅ Profile saved to: {profile_file}")

            return result

        except ImportError:
            print("‚ùå cProfile not available")
            return self.run_quick_tests()

    def _test_imports(self) -> bool:
        """Test that all modules can be imported."""
        try:
            from scirag import SciRag, SciRagEnhanced
            from scirag.enhanced_processing import (
                MathematicalProcessor, ContentClassifier, EnhancedChunker,
                AssetProcessor, GlossaryExtractor
            )
            return True
        except ImportError as e:
            print(f"    Import error: {e}")
            return False

    def _test_basic_functionality(self) -> bool:
        """Test basic functionality."""
        try:
            from scirag.enhanced_processing import MathematicalProcessor

            processor = MathematicalProcessor(enable_sympy=True)
            result = processor.process_equation("E = mc^2")

            return (result is not None and
                    result['equation_type'] == 'equation' and
                    result['complexity_score'] > 0)
        except Exception as e:
            print(f"    Functionality error: {e}")
            return False

    def _test_configuration(self) -> bool:
        """Test configuration."""
        try:
            from scirag.config import enhanced_config

            # Test configuration access
            has_required_attrs = all(
                hasattr(
                    enhanced_config,
                    attr) for attr in [
                    'ENABLE_ENHANCED_PROCESSING',
                    'ENABLE_MATHEMATICAL_PROCESSING',
                    'ENABLE_ASSET_PROCESSING',
                    'ENABLE_GLOSSARY_EXTRACTION'])

            return has_required_attrs
        except Exception as e:
            print(f"    Configuration error: {e}")
            return False

    def _test_error_handling(self) -> bool:
        """Test error handling."""
        try:
            from scirag.enhanced_processing import MathematicalProcessor

            processor = MathematicalProcessor(enable_sympy=True)

            # Test with invalid input
            result = processor.process_equation("")
            if result is None:
                return False

            # Test with malformed input
            result = processor.process_equation("invalid latex \\invalid{")
            if result is None:
                return False

            return True
        except Exception as e:
            print(f"    Error handling error: {e}")
            return False

    def _test_mathematical_processor(self) -> bool:
        """Test mathematical processor component."""
        try:
            from scirag.enhanced_processing import MathematicalProcessor

            processor = MathematicalProcessor(enable_sympy=True)

            # Test various equations
            equations = [
                "E = mc^2",
                "\\frac{d}{dx}[f(x)] = \\lim_{h \\to 0} \\frac{f(x+h) - f(x)}{h}",
                "\\int_{-\\infty}^{\\infty} e^{-x^2} dx = \\sqrt{\\pi}"]

            for equation in equations:
                result = processor.process_equation(equation)
                if result is None or result['equation_type'] == 'unknown':
                    return False

            return True
        except Exception as e:
            print(f"    Mathematical processor error: {e}")
            return False

    def _test_content_classifier(self) -> bool:
        """Test content classifier component."""
        try:
            from scirag.enhanced_processing import ContentClassifier

            classifier = ContentClassifier()

            # Test different content types
            test_cases = [
                ("This is prose text.", "prose"),
                ("Figure 1: A diagram.", "figure"),
                ("Table 2: Results.", "table"),
            ]

            for text, expected_type in test_cases:
                content_type = classifier.classify_content(text, {})
                if content_type is None:
                    return False

            return True
        except Exception as e:
            print(f"    Content classifier error: {e}")
            return False

    def _test_enhanced_chunker(self) -> bool:
        """Test enhanced chunker component."""
        try:
            from scirag.enhanced_processing import EnhancedChunker

            chunker = EnhancedChunker(chunk_size=1000, overlap_ratio=0.2)

            # Test chunking
            text = "This is a test document with multiple sentences. " * 10
            chunks = chunker.chunk_text(text, "test_doc")

            return len(chunks) > 0
        except Exception as e:
            print(f"    Enhanced chunker error: {e}")
            return False

    def _test_asset_processor(self) -> bool:
        """Test asset processor component."""
        try:
            from scirag.enhanced_processing import AssetProcessor

            processor = AssetProcessor()

            # Test asset processing
            result = processor.process_asset(
                "Figure 1: Test figure", "test_doc")

            return True  # Should not raise exception
        except Exception as e:
            print(f"    Asset processor error: {e}")
            return False

    def _test_glossary_extractor(self) -> bool:
        """Test glossary extractor component."""
        try:
            from scirag.enhanced_processing import GlossaryExtractor

            extractor = GlossaryExtractor()

            # Test glossary extraction
            text = "The term 'energy' refers to the capacity to do work."
            terms = extractor.extract_glossary_terms(text, "test_doc")

            return isinstance(terms, list)
        except Exception as e:
            print(f"    Glossary extractor error: {e}")
            return False

    def _test_enhanced_scirag(self) -> bool:
        """Test enhanced SciRAG component."""
        try:
            from scirag import SciRagEnhanced

            enhanced_scirag = SciRagEnhanced(
                enable_enhanced_processing=True,
                enable_mathematical_processing=True,
                enable_asset_processing=True,
                enable_glossary_extraction=True
            )

            # Test initialization
            return enhanced_scirag is not None
        except Exception as e:
            print(f"    Enhanced SciRAG error: {e}")
            return False


def main():
    """Main entry point."""
    parser = argparse.ArgumentParser(
        description="Enhanced SciRAG Development Test Runner")
    parser.add_argument(
        "--quick",
        action="store_true",
        help="Run quick smoke tests")
    parser.add_argument(
        "--unit",
        action="store_true",
        help="Run unit tests only")
    parser.add_argument(
        "--integration",
        action="store_true",
        help="Run integration tests only")
    parser.add_argument(
        "--performance",
        action="store_true",
        help="Run performance tests only")
    parser.add_argument(
        "--component",
        type=str,
        help="Test specific component")
    parser.add_argument(
        "--watch",
        action="store_true",
        help="Watch mode for continuous testing")
    parser.add_argument(
        "--coverage",
        action="store_true",
        help="Run with coverage")
    parser.add_argument(
        "--profile",
        action="store_true",
        help="Run with profiling")

    args = parser.parse_args()

    runner = DevelopmentTestRunner()

    if args.watch:
        runner.run_watch_mode()
    elif args.profile:
        result = runner.run_with_profiling()
        sys.exit(0 if result['failed'] == 0 else 1)
    elif args.component:
        result = runner.run_component_tests(args.component)
        sys.exit(0 if result['passed'] else 1)
    elif args.quick or not any([args.unit, args.integration, args.performance]):
        result = runner.run_quick_tests()
        sys.exit(0 if result['failed'] == 0 else 1)
    else:
        # Run specific test types using pytest
        pytest_args = ["-v"]

        if args.unit:
            pytest_args.extend(["-m", "unit"])
        if args.integration:
            pytest_args.extend(["-m", "integration"])
        if args.performance:
            pytest_args.extend(["-m", "performance"])
        if args.coverage:
            pytest_args.extend(["--cov=scirag", "--cov-report=term"])

        try:
            subprocess.run([sys.executable, "-m", "pytest"] +
                           pytest_args, check=True)
            sys.exit(0)
        except subprocess.CalledProcessError:
            sys.exit(1)


if __name__ == "__main__":
    main()